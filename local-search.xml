<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解 iOS 中的锁</title>
    <link href="/2023/04/27/ios-lock/"/>
    <url>/2023/04/27/ios-lock/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳实践之APM建设</title>
    <link href="/2023/04/23/ios-apm/"/>
    <url>/2023/04/23/ios-apm/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
      <category>最佳实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳实践之性能优化</title>
    <link href="/2023/04/23/ios-app-perf/"/>
    <url>/2023/04/23/ios-app-perf/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
      <category>最佳实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解启动流程</title>
    <link href="/2023/04/23/ios-app-startup/"/>
    <url>/2023/04/23/ios-app-startup/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Class</title>
    <link href="/2023/04/20/ios-class/"/>
    <url>/2023/04/20/ios-class/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Category</title>
    <link href="/2023/04/20/ios-category/"/>
    <url>/2023/04/20/ios-category/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Block</title>
    <link href="/2023/04/20/ios-block/"/>
    <url>/2023/04/20/ios-block/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><p>Block 是 <code>Objective-C（简称OC）</code> 中对闭包（Closure）的实现，果爹通过一系列黑活保证其拥有闭包的特性，又能装成 <code>OC</code> 对象被使用。关于 Block 的一些认识现在被纳入八股文体系中，那么我就不得不梳理一篇文章出来，以备不时之需。</p><span id="more"></span><p>整体分成五块内容：</p><ul><li>基本原理</li><li>类型介绍</li><li>特性分析</li><li>内存管理</li><li>扩展</li></ul><h2 id="%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" tabindex="-1">基本原理</h2><p>对于 Block 的声明和函数指针基本一样，它的调用本质其实也是函数指针的调用。</p><ul><li>函数指针的定义</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">返回类型 <span class="hljs-comment">(*指针变量名称)</span> <span class="hljs-comment">(参数)</span><br></code></pre></td></tr></table></figure><ul><li>Block 的定义</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">返回类型 <span class="hljs-comment">(^Block名称)</span> <span class="hljs-comment">(参数)</span><br></code></pre></td></tr></table></figure><p>那么 Block 是如何体现闭包特性的，又是如何被调用的呢？先在 Demo 中实现代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-type">int</span> age = <span class="hljs-number">30</span>;<br>        <span class="hljs-type">void</span>(^block)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = ^(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d%d退休&quot;</span>, a, b);<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;age = %d&quot;</span>, age);<br>        &#125;;<br>        block(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code> 将代码展开成 <code>main.cpp</code>，在生成的 cpp 文件底部可以找到代码，注释当然是我另加的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Block 的数据结构</span><br><span class="hljs-keyword">struct</span> __block_impl &#123;<br>  <span class="hljs-type">void</span> *isa;    <span class="hljs-comment">//isa指针，oc对象都有这个指针</span><br>  <span class="hljs-type">int</span> Flags;    <span class="hljs-comment">//标识</span><br>  <span class="hljs-type">int</span> Reserved; <span class="hljs-comment">//保留字段，默认=0</span><br>  <span class="hljs-type">void</span> *FuncPtr;    <span class="hljs-comment">//block 的函数指针</span><br>&#125;;<br><br><span class="hljs-comment">/// 最前面是block 所在的方法名，第几个结尾的数字就递增</span><br><span class="hljs-comment">/// 这个 struct 主要用来承载我们声明的 block 实例</span><br><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-comment">/// 函数指针和 OC 对象结合的胶水类，原型是 Block_layout</span><br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-comment">/// 当前 block 的补充信息，因捕获变量的行为有所变化，文章下面有展开</span><br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  <span class="hljs-comment">/// 用到的上下文</span><br>  <span class="hljs-type">int</span> age;<br>  <span class="hljs-comment">/// 构造函数</span><br>  __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> _age, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : age(_age) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock; <span class="hljs-comment">/// 这里比较有意思，指定 Block 实例在 OC 中的对象类型，文章下面有展开</span><br>    impl.Flags = flags; <br>    impl.FuncPtr = fp;  <br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">/// Block 对应的待执行函数</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>  <span class="hljs-type">int</span> age = __cself-&gt;age; <span class="hljs-comment">// bound by copy</span><br>  <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_v2_h365bjbs0kvdryv303hjf5tw0000gn_T_main_1dbf33_mi_0, a, b);<br>  <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_v2_h365bjbs0kvdryv303hjf5tw0000gn_T_main_1dbf33_mi_1, age);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br><br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        <span class="hljs-type">int</span> age = <span class="hljs-number">30</span>;<br>        <span class="hljs-comment">/// 看着复杂，实际上就是初始化 __main_block_impl_0，然后取地址得到首个变量 impl 的地址，然后干活</span><br>        <span class="hljs-type">void</span>(*block)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>) = ((<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>))&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));<br>        ((<span class="hljs-type">void</span> (*)(__block_impl *, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中可以看出，在 Block 的代码展开后，其调用在 <code>block-&gt;FuncPtr</code> 这里，这也就意味着 Block 的调用不走 OC 消息转发。并且在 <code>__block_impl</code> 这个代表 Block 的结构体中，可以看到 <code>isa</code> 的存在，这也就意味着其对象特性是通过这里来实现的，可以通过一段有趣的代码一探究竟</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 这是个结构体，大家都看出来了吧</span><br><span class="hljs-keyword">struct</span> FakeObject &#123;<br>    Class isa;<br>&#125; FakeObject; <span class="hljs-comment">//在这就创建好了</span><br><br><span class="hljs-comment">// 对栈上的结构体 FakeObject 变量赋值，指定 isa 为 NSObject.class</span><br>FakeObject.isa = <span class="hljs-built_in">NSObject</span>.class;<br><br><span class="hljs-comment">// 取结构体首地址，也就是 isa 的地址，转成 NSObjct 类型的实例</span><br><span class="hljs-built_in">NSObject</span> *obj = (__bridge <span class="hljs-built_in">NSObject</span>*)&amp;FakeObject;<br><span class="hljs-comment">// 是的，这里就可以给这个结构体发消息了</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, obj.description);<br></code></pre></td></tr></table></figure><p>可以看到这里相当于在<strong>栈上</strong>创建了一个 <code>NSObject</code> 实例，再看看上面 Block 展开代码中的 <code>isa</code> 处理</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">impl.isa = &amp;_NSConcreteStackBlock<br></code></pre></td></tr></table></figure><p>这里的代码意图就很清晰了，至于为什么这么绕这么设计，<strong>前言</strong>就说了它要有闭包特性，又能装成 OC 对象。闭包特性好说，装成 OC 对象是干啥的呢？<br>除了响应一切皆对象的口号，看起来更 OC，更重要的是能参与 OC 的内存管理那套，用起来也 OC，不然声明就直接对接函数指针了，两者几乎一致，搞那些有的没有，搞的自己很帅。<br>言归正传，下面我们详细说说这个 <code>isa</code> 指向的几种 Block 对象。</p><h2 id="%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D" tabindex="-1">类型介绍</h2><p>具体有哪些类型基本上都能在 <code>libclosure-79/data.m</code> 中看到，这里一一列举介绍。</p><h3 id="nsblock" tabindex="-1">NSBlock</h3><p>通过源码 <code>libclosure-79/data.m</code> 中的注释可以了解到，NSBlock 是动态插入作为 __NSXXXBlock 的父类。由于各种原因（偷懒），我也就没有去探查下去。</p><blockquote><p>We define these classes, and CF will later when it initializes inject NSBlock as the real parent for <code>__NSStackBlock__</code>, <code>__NSMallocBlock__</code>,<code>__NSAutoBlock__</code> and <code>__NSGlobalBlock__</code>.</p></blockquote><h3 id="__nsstackblock__" tabindex="-1">__NSStackBlock__</h3><p>顾名思义，表示分配在栈上的 Block 类型。通常 Block 中访问了外部临时变量且没有 copy 调用，那么这时候 Block就是该类型，这也是 Block 的默认类型。下方的代码即是一个 StackBlock</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;age = %d&quot;</span>, ^<span class="hljs-type">int</span>()&#123;<br>  <span class="hljs-keyword">return</span> age;<br>&#125;());<br></code></pre></td></tr></table></figure><p>可以通过简单的调试确认（直接Assembly看汇编也可以）</p><ol><li>先输出 <code>__NSStackBlock__</code> 的地址，即</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p&quot;</span>, <span class="hljs-built_in">NSClassFromString</span>(<span class="hljs-string">@&quot;__NSStackBlock__&quot;</span>));<br><br><span class="hljs-comment">/// 控制台输出如下</span><br><span class="hljs-number">2023</span><span class="hljs-number">-04</span><span class="hljs-number">-24</span> <span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">14.497729</span>+<span class="hljs-number">0800</span> BlockDemo[<span class="hljs-number">21136</span>:<span class="hljs-number">16771217</span>] <span class="hljs-number">0x1001f8018</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在 <code>return age;</code> 处下断点，进入断点后，在控制台输入 <code>frame info</code> 可以查看当前执行栈信息，类似如下，这其中 <code>block_descriptor=0x000000016fdfedf8</code> 可以看成是上面示例代码中的<code>__block_impl</code>，那么首地址即是指定Block对象的 <code>isa</code> 的地址</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">frame #<span class="hljs-number">0</span>: <span class="hljs-number">0x0000000100003ecc</span> BlockDemo`__main_block_invoke(.block_descriptor=<span class="hljs-number">0x000000016fdfedf8</span>) at main.mm:<span class="hljs-number">70</span>:<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在控制台输出 <code>mem read 0x000000016fdfedf8</code>，可以得到内存信息如下，首行对应的这个地址。由于 iOS 是小端模式，需要转换字节序，转换后对比步骤1中的地址，可以看到是一致的</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-number">0x16fdfedf8</span>: <span class="hljs-number">18</span> <span class="hljs-number">80</span> <span class="hljs-number">1</span>f <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> c0 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  ................<br><span class="hljs-number">0x16fdfee08</span>: b8 <span class="hljs-number">3</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  .&gt;.......@......<br></code></pre></td></tr></table></figure><h3 id="__nsmallocblock__" tabindex="-1">__NSMallocBlock__</h3><p>表示存放于堆上的 Block 类型，这种 Block 几乎只能由内部的 copy 操作生成，我们日常开发是无法直接创建的。比如上面示例代码中的 <code>void(^block)(int ,int)</code> 赋值过程，可以理解为：</p><ul><li>声明了一个匿名 Block，对应 <code>__NSStackBlock__</code></li><li>赋值给左边的 <code>block</code> 实例时，由于默认 ARC 的情况下，左边的实例为<code>__strong</code> 修饰，那么编译器会插入的 <code>copy</code> 调用</li><li>最终 <code>block</code> 实例对应的是 <code>__NSMallocBlock__</code></li></ul><p>在 ARC 环境下，一般会自动将 StackBlock 拷贝成 MallocBlock 的情况有：</p><ul><li>作为函数返回值</li><li>赋值给 __strong 的实例</li><li>系统SDK的方法中带有 <code>usingBlock</code> 的参数</li><li>GCD的调用入参</li></ul><h3 id="__nsglobalblock__" tabindex="-1">__NSGlobalBlock__</h3><p>在 Block 中访问了外部全局变量或静态局部变量的时候，对应的即是该类型。就按照 <code>static void block()</code> 这种静态方法理解好了，其调用编译时就确定了，然后打在 <code>__DATA</code> 数据段中。<br>比如下面的代码就是个 GlobalBlock，可以通过分析栈Block段落里的方法确认</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;age = %d&quot;</span>, ^<span class="hljs-type">int</span>()&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>;<br>&#125;());<br></code></pre></td></tr></table></figure><h3 id="__nsautoblock__" tabindex="-1"><s>__NSAutoBlock__</s></h3><p>参与 GC 对 Block 进行内存管理的相关逻辑</p><h3 id="__nsfinalizingblock__" tabindex="-1"><s>__NSFinalizingBlock__</s></h3><p>继承于 <code>__NSAutoBlock__</code> 的类，也是算个助力 GC 内存管理的功能类吧</p><h3 id="__nsblockvariable__" tabindex="-1"><s>__NSBlockVariable__</s></h3><p>GC配套，注释也说明的很清楚，感兴趣就自行探究吧（doge）。</p><h2 id="%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90" tabindex="-1">特性分析</h2><p>开头的示例代码中，我们声明的 Block 代码会被编译器转换成一个静态函数，即 <code>__main_block_func_0</code>，内部需要的变量都通过参数传进来，这没问题，可是一旦函数内部需要修改这些外部变量的值，那么问题就来了，如何保证这些值在函数内使用期间没有被释放，如何保证修改会影响原始值等等等等，下面会就此展开介绍。</p><h3 id="%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7" tabindex="-1">变量捕获</h3><p>为了保证 Block 内部能够正常访问外部变量，这里就引入了一个变量捕获机制（闭包都有，不是新鲜事儿）。同时其捕获机制针对不同类型的变量体现了不同的策略，因而显得复杂起来，加入了八股文中。这里按临时变量，局部静态变量，全局变量介绍，示例代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> c = <span class="hljs-number">100</span>; <span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">200</span>; <span class="hljs-comment">// 静态变量</span><br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">35</span>; <span class="hljs-comment">// 临时变量</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">50</span>; <span class="hljs-comment">// 局部静态变量</span><br>        <span class="hljs-type">void</span>(^block)(<span class="hljs-type">void</span>) = ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;a = %d, b = %d, c = %d, d = %d&quot;</span>, a, b, c, d);<br>        &#125;;<br>        block();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码展开后</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  <span class="hljs-type">int</span> a;<br>  <span class="hljs-type">int</span> *b;<br>  __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, <span class="hljs-type">int</span> _a, <span class="hljs-type">int</span> *_b, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : a(_a), b(_b) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>  <span class="hljs-type">int</span> a = __cself-&gt;a; <span class="hljs-comment">// bound by copy</span><br>  <span class="hljs-type">int</span> *b = __cself-&gt;b; <span class="hljs-comment">// bound by copy</span><br><br>            <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_v2_h365bjbs0kvdryv303hjf5tw0000gn_T_main_6f6854_mii_0, a, (*b), c, d);<br>        &#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br><br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        <span class="hljs-type">int</span> a = <span class="hljs-number">35</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">50</span>;<br>        <span class="hljs-type">void</span>(*block)(<span class="hljs-type">void</span>) = ((<span class="hljs-type">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, &amp;b));<br>        ((<span class="hljs-type">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F" tabindex="-1">临时变量</h4><p>从上述代码中可以看到，在 <code>__main_block_impl_0</code> 中定义了 <code>int a</code> 的成员变量来储存要访问的临时变量 <code>a</code>，考虑到访问安全，变量传值方式为值传递。</p><h4 id="%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F" tabindex="-1">局部静态变量</h4><p><code>__main_block_impl_0</code> 中定义了 <code>int *b</code> 存储要访问的局部静态变量 <code>b</code>，因为静态变量的特性，传值方式为引用传递。</p><h4 id="%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" tabindex="-1">全局变量</h4><p>很明显，在 <code>__main_block_impl_0</code> 中根本就没出现 <code>c</code> 和 <code>d</code> 的成员变量，也就是说这两个变量不需要捕获，因为其本身就支持跨函数访问。</p><h4 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h4><p>局部变量都会被block捕获，临时变量是值捕获，静态变量为地址捕获，全局变量不会被捕获。</p><table style="text-align: center;"><tr>    <th colspan="2" style="text-align: center">变量类型</th>    <th style="text-align: center">处理策略</th>    <th style="text-align: center">访问方式</th></tr><tr>    <td rowspan="2">局部变量</td>    <td>临时变量</td>    <td>捕获</td>    <td>值</td></tr><tr>    <td>局部静态变量</td>    <td>捕获</td>    <td>引用</td></tr><tr>    <td colspan="2">全局变量</td>    <td>无需捕获</td>    <td>直接</td></tr></table><h3 id="%E4%BF%AE%E9%A5%B0%E8%AF%8D" tabindex="-1">修饰词</h3><p>为满足实际开发中的各种需要，Block 还需要搭配不同的修饰词使用。</p><h4 id="__block" tabindex="-1">__block</h4><p>简单来说，<code>__block</code> 作用是允许 Block 内部修改从外部捕获的变量。<br>示例代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        __block <span class="hljs-type">int</span> a = <span class="hljs-number">35</span>;<br>        <span class="hljs-type">void</span>(^block)(<span class="hljs-type">void</span>) = ^&#123;<br>            a = <span class="hljs-number">50</span>;<br>        &#125;;<br>        block();<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;a = %d&quot;</span>, a);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>展开后的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __Block_byref_a_0 &#123;<br>  <span class="hljs-type">void</span> *__isa; <span class="hljs-comment">// 万一是 OC 对象呢</span><br>__Block_byref_a_0 *__forwarding;<br> <span class="hljs-type">int</span> __flags;<br> <span class="hljs-type">int</span> __size;<br> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  __Block_byref_a_0 *a; <span class="hljs-comment">// by ref</span><br>  __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : a(_a-&gt;__forwarding) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __main_block_func_0(<span class="hljs-keyword">struct</span> __main_block_impl_0 *__cself) &#123;<br>  __Block_byref_a_0 *a = __cself-&gt;a; <span class="hljs-comment">// bound by ref</span><br>  (a-&gt;__forwarding-&gt;a) = <span class="hljs-number">50</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __main_block_copy_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*dst, <span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="hljs-type">void</span>*)&amp;dst-&gt;a, (<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __main_block_dispose_0(<span class="hljs-keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="hljs-type">void</span>*)src-&gt;a, <span class="hljs-number">8</span><span class="hljs-comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> __main_block_desc_0 &#123;<br>  size_t reserved;<br>  size_t Block_size;<br>  <span class="hljs-type">void</span> (*<span class="hljs-keyword">copy</span>)(<span class="hljs-keyword">struct</span> __main_block_impl_0*, <span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>  <span class="hljs-type">void</span> (*dispose)(<span class="hljs-keyword">struct</span> __main_block_impl_0*);<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;<br><br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        __attribute__((__blocks__(<span class="hljs-keyword">byref</span>))) __Block_byref_a_0 a = &#123;(<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(__Block_byref_a_0), <span class="hljs-number">35</span>&#125;;<br>        <span class="hljs-type">void</span>(*block)(<span class="hljs-type">void</span>) = ((<span class="hljs-type">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="hljs-number">570425344</span>));<br>        ((<span class="hljs-type">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);<br>        <span class="hljs-built_in">NSLog</span>((<span class="hljs-built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_v2_h365bjbs0kvdryv303hjf5tw0000gn_T_main_c3aed9_mii_0, (a.__forwarding-&gt;a));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，相比只读情况的代码多了 <code>__Block_byref_a_0</code>，以及在 <code>__main_block_desc_0</code> 中多了 copy 和 dispose 的函数，并可以对应找到其生成的代码。<br>不难看出，copy 和 dispose 操作的是 <code>__main_block_impl_0</code> 实例，内部调用了 Block 源码中的 <code>_Block_object_assign</code> 及 <code>_Block_object_dispose</code>，这两个函数的实现就躺在 <code>libclosure-79/runtime.c</code> 里，注释写的很详细，主打一个内存管理。</p><p>上下文中由原先操作变量 <code>a</code> 的地方，都给改成了操作 <code>__Block_byref_a_0</code> 实例的成员变量，这都是编译器干的好事，主要包括以下几点</p><ol><li>将 <code>__block</code> 变量包装成一个结构体 <code>__Block_byref_a_0</code></li><li>结构体内部 <code>*__forwarding</code> 是指向自身的指针</li><li>结构体内部还存储着外部 <code>a</code> 的值</li></ol><p>此时如果 <code>block</code> 是在栈上，那么这个 <code>__forwarding</code> 指针就是指向它自己；当这个 <code>block</code> 从栈上复制到堆上后，栈上的 <code>__forwarding</code> 指针指向的是复制到堆上的 <code>__block</code> 结构体，堆上的 <code>__block</code> 结构体中的 <code>__forwarding</code> 指向的还是它自己，即 <code>a-&gt;__forwarding</code> 获取到堆上的 <code>__block</code>，<code>a-&gt;__forwarding-&gt;a</code> 会把堆上的 <code>a</code> 赋值为 50。因此不管是栈上还是堆上的 <code>__block</code> 结构体，最终操作的都是堆上的 <code>__block</code> 结构体里面的数据。</p><h4 id="__weak" tabindex="-1">__weak</h4><p>Block 在捕获变量时，会保留其引用关系，也就是说如果使用 <code>__weak</code> 修饰外部变量，在内部生成 block 相关数据结构时，其存储的捕获变量也会带有该标记。</p><blockquote><p>展开成 C++ 时遇到错误，原因是 <code>__weak</code> 是运行时支持的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">cannot create __<span class="hljs-keyword">weak</span> reference because the current deployment target does not support <span class="hljs-keyword">weak</span> references<br></code></pre></td></tr></table></figure><p>修改命令为 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code> 即可</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  Person *__<span class="hljs-keyword">weak</span> weakP; <span class="hljs-comment">/// 看这</span><br>  __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, Person *__<span class="hljs-keyword">weak</span> _weakP, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : weakP(_weakP) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="__unsafe_unretained" tabindex="-1">__unsafe_unretained</h4><p>原理上同 <code>__weak</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  Person *__<span class="hljs-keyword">unsafe_unretained</span> p; <span class="hljs-comment">/// 看这</span><br>  __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, Person *__<span class="hljs-keyword">unsafe_unretained</span> _p, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : p(_p) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="__strong" tabindex="-1">__strong</h4><p>默认情况下，对象的实例都是 <code>__strong</code> 修饰的，所以展开后的代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  Person *__<span class="hljs-keyword">strong</span> p; <span class="hljs-comment">/// 看这</span><br>  __main_block_impl_0(<span class="hljs-type">void</span> *fp, <span class="hljs-keyword">struct</span> __main_block_desc_0 *desc, Person *__<span class="hljs-keyword">strong</span> _p, <span class="hljs-type">int</span> flags=<span class="hljs-number">0</span>) : p(_p) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" tabindex="-1">内存管理</h2><p>这块也算是八股文里的重点了，因为 Block 在实际使用中，其特殊机制带来的影响，大家或多或少都踩过一下内存管理上的坑，所以有必要单独拿出来说说。</p><h3 id="%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8" tabindex="-1">循环引用</h3><blockquote><p>你中有我，我中有你，两者不离不弃，至死不渝。<br>循环引用的场景不用多说，一句话表达就是两个及以上的对象互相强引用导致其无法正常析构的情况。常见的有 <code>delegate</code> 导致的循环引用问题，所以一般都使用 <code>weak</code> 修饰以避免。当然还有我们现在说的 Block，这也是重灾区。</p></blockquote><h3 id="mrc" tabindex="-1">MRC</h3><p>通过 <code>__unsafe_unretained</code> 和 <code>__block</code> 解决循环引用问题，通过上面大篇幅的介绍也能容器理解。在捕获变量的内部数据结构中，打破强引用链。这里单独说下 <code>__block</code>，在 MRC 模式下，捕获变量时不会对其 <code>retain</code>，这也是有别于 ARC 模式的情况。</p><h3 id="arc" tabindex="-1">ARC</h3><p>一般通过使用 <code>__weak</code> 修饰持有当前 Block 的外部变量，在 Block 作用域内再通过 <code>__strong</code> 修饰以获取当前作用域内相对持久的变量，继续执行后续逻辑。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">__<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br><span class="hljs-type">void</span> (^exampleBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>    __<span class="hljs-keyword">strong</span> __<span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>    [strongSelf exampleFunc];<br>&#125;;<br></code></pre></td></tr></table></figure><p>严格来讲，<code>weak strong dance</code> 并不算完美解法，更多的可能是为了在多层级 Block 嵌套式，能够让强弱引用的变量有一一对应的关系，增加可读性吧。而其不完美之处在于 Block 在被执行的过程中，同样存在外部变量 <code>self</code> 被提前释放的情况，这时候 <code>strongSelf</code> 可能就是 <code>nil</code>，因为原始值已经释放了。此时给这个变量发消息没问题，OC 的消息机制支持给空对象发消息，但是一旦涉及添加进数组等操作时，还是会 crash 的。所以还需要增加防护措施</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">__<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br><span class="hljs-type">void</span> (^exampleBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>    __<span class="hljs-keyword">strong</span> __<span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>    <span class="hljs-keyword">if</span> (strongSelf) &#123;<br>        <span class="hljs-comment">// Add operation here</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="%E6%89%A9%E5%B1%95" tabindex="-1">扩展</h2><p><code>Block_layout</code> 结构体</p><ul><li>isa: 指向所属类的指针，也就是 Block 的类型</li><li>flags: 按 bit 位表示一些 Block 的附加信息，比如判断 block 类型、判断 Block 引用计数、判断 block 是否需要执行辅助函数等；</li><li>reserved: 保留变量；</li><li>invoke: Block 函数指针，指向具体的 Block 实现的函数调用地址，Block 内部的执行代码都在这个函数中；</li><li>descriptor: 结构体 Block_descriptor，Block 的附加描述信息，包含 copy/dispose 函数，Block 的大小，保留变量；</li><li>variables: 因为 Block 有闭包性，所以可以访问 Block 外部的局部变量。这些 variables 就是复制到结构体中的外部局部变量或变量的地址；</li></ul><p><code>Block_descriptor</code> 结构体</p><ul><li>reserved: 保留变量；</li><li>size: Block 的大小；</li><li>copy: 函数用于捕获变量并持有引用；</li><li>dispose: 析构函数，用来释放捕获的资源；</li><li>signature: Block 的方法签名</li><li>layout: Block 中有访问外部变量和对象，返回 <code>Block_descriptor_3</code> 的<code>layout</code> 信息</li></ul><h3 id="%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D" tabindex="-1">方法签名</h3><p>对的，Block 同样有签名，装就装到底。获取的思路也很简单，就是造个和内部 <code>Block_layout</code> 一样的结构体，直接将 block 实例强转成改结构体，即可在 <code>descriptor</code> 中拿到对应签名。当然也需要结合对源码的阅读，增加必要的 <code>flags</code> 方面的判断，以减少异常情况。</p><h3 id="hook" tabindex="-1">Hook</h3><p>常见的就 3 种吧，只列举，不展开，资料一搜一大把。</p><ol><li>通过 <code>libffi</code> 直接对 Block 中的 <code>invoke</code> 下手。</li><li>也是对 <code>invoke</code> 下手，通过设置其指针为 <code>_objc_msgForward</code>，这样在调用 Block 时就强制进入消息转发流程，再 hook 掉 <code>NSBlock</code> 的相关消息转发的方法，也还行吧。</li><li>构造 hook block，然后强转成 <code>Block_layout</code> 结构体，替换双方的 invoke，也能勉强满足交换需求</li></ol><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><p>写到后面越写越水，这倒不是因为我懒（就是吧~），也是最近今日事务繁多，搞的我心力交瘁，成年人的世界哪有容易二字。</p><p>本篇通过对 Block 做了一些分析，除了常规性的技术总结之外，也算是为了日后八股文考试时能增加些自信心吧，分析过和没分析过还真就不一样。至于对个人水平和能力的体现，还是那句话，这 iOS 开发就那些东西，多少年了也没什么变化。</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Runtime</title>
    <link href="/2023/04/20/ios-runtime/"/>
    <url>/2023/04/20/ios-runtime/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 RunLoop</title>
    <link href="/2023/04/20/ios-runloop/"/>
    <url>/2023/04/20/ios-runloop/</url>
    
    <content type="html"><![CDATA[<h1 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h1><span id="more"></span><h1 id="%E5%90%8E%E8%AF%AD" tabindex="-1">后语</h1><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>底层原理</category>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hey gay, @property了解下</title>
    <link href="/2020/09/01/ios-property/"/>
    <url>/2020/09/01/ios-property/</url>
    
    <content type="html"><![CDATA[<p>先说点废话，看过一个段子说是面试问 weak 的经历，大概是这样：</p><ul><li><p>2014年<br><strong>A：</strong> weak是什么<br><strong>B：</strong> 弱引用，释放时自动置nil<br><strong>A：</strong> 明天来上班</p></li><li><p>2016年<br><strong>A：</strong> weak是什么<br><strong>B：</strong> 弱引用，释放时自动置nil，内部通过哈希表维护，<br><strong>A：</strong> 回去等通知</p></li><li><p>2018年<br><strong>A：</strong> weak是什么<br><strong>B：</strong> 弱引用，释放时自动置nil，内部通过哈希表维护，runtime里是这样(&gt;=2000字)实现的<br><strong>A：</strong> 回去等通知</p></li><li><p>2020年<br><strong>A：</strong> weak是…<br><strong>B：</strong> 别说了，我现场给你写个出来<br><strong>A：</strong> 小伙子挺不错的，回去等通知</p></li></ul><span id="more"></span><p>站在面试者的角度来讲，这种问题别问，问就是装逼，开发能用到？对于正经的面试官来讲，为了筛选喜欢探索、喜欢折腾、喜欢刨根问底的人才。立场和角度不同，所以没有所谓的对错，只是确实有一篇篇“底层探索、原理解析”的文章流传在网络上，供大家在面试前疯狂翻阅背诵，这也正是恶性循环的开始。</p><p><strong>正能量：</strong> 我也曾有过这种经历，然而转念一想，其实那些文章的作者花心思花时间总结出来给大家阅读，确实是带来正能量的。我们除了白嫖，默默地看完然后继续下一篇之外，是否真的有从里面总结提炼出可以化为自身能力的东西呢，还是说仅仅是增加了面试的筹码而已。举个场景，若干年后地iOS开发，语言已全面换成swift了，而你所铭记在心的weak原理早已蒙尘许久，然后呢，开始新一轮的swift底层原理的文章通览默记，去应对下一场面试，完全不正能量啊。如果说天资过人，鸿运当头，早早的实现财务自由，创业成功，晋升高管，那肯定看不到我现在写的圣母文。我想强调的是，对大多数平凡而努力的开发者而言，心中无码才是至高境界啊，牛逼的是逻辑思维能力，是与众不同的想法，是高效做事的方法，而不是底层原理啊。</p><p>经过开篇正能量的洗礼后，我们来谈谈本文的主题，了解下OC里的<code>property</code>，限于篇幅和水平，细节点就不贴代码凑字数了，有兴趣的可以自己去探索。</p><h3 id="%E5%B1%9E%E6%80%A7%E7%9A%84%E6%9C%AC%E8%B4%A8" tabindex="-1">属性的本质</h3><p>直观点就按着<code>property = setter + getter + ivar</code>理解，而按照果爹的官宣来讲，OC里的属性是通过<code>@property</code>定义的公开或私有的方法，具体点来讲还牵扯到编译器的新老更迭导致的coding方式不同。本文就基于<code>Clang-LLVM</code>的新编译器做理解分析就好，不扩展，不粘贴。而分析方法其实很早之前我们的语文老师已经教过我们了，说是英语老师教的也行，我们可以按着主谓宾来拆解。</p><p>代码的本质是语言，机器和人都有各自的方言，那么编译器就负责双向的翻译。套用到这里，类似<code>@property xxx</code>就是一句类似你弄啥咧的方言，是给我们开发者看的，这句话机器就听不懂，就得由美女翻译官在线翻译，把意思转诉给机器。整个流程就是我们声明属性，编译器生成<code>setter</code>、<code>getter</code>、实例，再转诉给机器，帮助我们完成想要做的事情，传递想要表达的意思。我们先看看属性的整体结构都是个啥：<br><img src="/2020/09/01/ios-property/property.jpg" alt></p><p>我们关注的一般都在括号里“复词”的部分，所以我尽量罗列些能找到的关键字：</p><ul><li><code>atomic</code> &amp; <code>nonatomic</code></li><li><code>readwrite</code> &amp; <code>readonly</code></li><li><code>weak</code> &amp; <code>assign</code> &amp; <code>unsafe_unretained</code></li><li><code>copy</code> &amp; <code>strong</code> &amp; <code>retain</code></li><li><code>nullable</code> &amp; <code>nonnull</code></li><li><code>setter</code> &amp; <code>getter</code></li><li><code>null_resettable</code> &amp; <code>null_unspecified</code></li><li><code>class</code></li></ul><p>按照结构图的归纳，其实分类后就一丢丢，以后的重心会是swift，OC的话可能很少再新增特性了。平时我们用的也频繁，不如做个全面了解纪念下，留着以后给孩子讲故事用。我们看看这些方言想要表达意思，究竟是个啥。</p><h3 id="%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89" tabindex="-1">各个关键字的含义</h3><p>简单先说下<code>@synthesize</code>和<code>@dynamic</code>，就是告诉编译器是否要自动合成属性，我们现在一般不特指的话都是会自动合成的，所以其实你每声明一个属性，都会有配套的<code>setter</code>、<code>getter</code>、<code>_ivar</code>生成，这也是有些包大小<strong>极端</strong>优化的文章里提到的需要处理的地方。这个没啥意思，我们再看看其他属性的组成部分。</p><h4 id="%E5%8E%9F%E5%AD%90%E6%80%A7" tabindex="-1">原子性</h4><p>由关键字<code>atomic</code>和<code>nonatomic</code>支持，默认是<code>atomic</code>，会告诉编译器在生成<code>setter</code>和<code>getter</code>方法时是否要加锁，以<strong>牺牲部分性能</strong>换来可靠的读写操作。这也就意味着，在调用<code>xxx.yyy</code>的时候会更慢，但不用担心<code>_yyy</code>在多线程读写过程中的竞争问题。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sas">// codes <span class="hljs-keyword">from</span> objc4-781<br><br>// the setter<br>&#123;<br>  ...<br>  <span class="hljs-keyword">if</span> (!atomic) &#123;<br>      oldValue = <span class="hljs-comment">*slot;</span><br>      <span class="hljs-comment">*slot = newValue;</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      spinlock_t&amp; slotlock = PropertyLocks[slot];<br>      slotlock.lock();<br>      oldValue = <span class="hljs-comment">*slot;</span><br>      <span class="hljs-comment">*slot = newValue;</span><br>      slotlock.unlock();<br>  &#125;<br>  ...<br>&#125;<br><br>// the getter<br>&#123;<br>  ...<br>  <span class="hljs-keyword">if</span> (!atomic) <span class="hljs-keyword">return</span> <span class="hljs-comment">*slot;</span><br><br>  spinlock_t&amp; slotlock = PropertyLocks[slot];<br>  slotlock.lock();<br>  id value = objc_retai<span class="hljs-meta">n</span>(<span class="hljs-comment">*slot);</span><br>  slotlock.unlock();<br>  <span class="hljs-keyword">return</span> objc_autoreleaseReturnValue(value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="%E8%AF%BB%E5%86%99" tabindex="-1">读写</h4><p>由关键字<code>readwrite</code>和<code>readonly</code>支持，默认的<code>readwrite</code>会让编译器同时生成<code>setter</code>和<code>getter</code>方法，而<code>readonly</code>的话顾名思义就只提供<code>getter</code>方法。</p><h4 id="%E8%BE%85%E5%8A%A9%E8%AF%8D" tabindex="-1">辅助词</h4><ul><li><p><code>nullable</code> &amp; <code>nonnull</code></p><p>用于标识该属性值是否可空，需要限定当前属性变量是指针式的，如<code>NSString *</code>、<code>int *</code>，而基础数据类型则不行。类比下<code>swift</code>的<code>?</code>和<code>!</code>，如果对一个<code>nonnull</code>修饰的属性赋值<code>nil</code>，<code>Xcode</code>会贴心地给你个黄牌警告。事实上，如果需要每个属性或每个方法的参数和返回值都去指定<code>nonnull</code>和<code>nullable</code>，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>，把它们插在在类文件头尾，那么所有的方法和属性都会自动加上<code>nonnull</code>关键字，我们可以单独指定那些需要<code>nullable</code>的部分。</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-built_in">NS_ASSUME_NONNULL_BEGIN</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> : <span class="hljs-title">UIViewController</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span><span class="hljs-comment">/*, nonnull*/</span>) <span class="hljs-built_in">UIView</span> *nonnullView;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">NSString</span> *nullableString;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-built_in">NS_ASSUME_NONNULL_END</span><br></code></pre></td></tr></table></figure><ul><li><p><code>setter</code> &amp; <code>getter</code><br>可以指定<code>set</code>方法或<code>get</code>方法的别名，没啥意思，但也聊两句骚话。命名一直是编程的头等大事，好的命名可以提高码农的读写效率至少30%，各方大哥大佬们想尽办法去寻找优秀的命名手段，大小驼峰啊，下划线啊，匈牙利啊，都是尝试去做到好的命名。举，这里我们声明属性<code>blue</code>，在赋值时可以叫<code>setBlue:</code>，很舒服，那么在用点语法调用<code>BOOL a = xxx.blue</code>时就不太爽，所以指定个别名<code>isBlue</code>变成<code>BOOL a = xxx.isBlue</code>，这样就爽很多。</p></li><li><p><code>null_resettable</code> &amp; <code>null_unspecified</code><br>这两个关键字也需要限定当前属性变量是指针式的，如<code>NSString *</code>、<code>int *</code>，而基础数据类型则不行。</p><ul><li>对于<code>null_resettable</code>，我们最熟悉的<code>UIViewController</code>，它的属性<code>view</code>即是用的此关键字，意味着我们可以对该属性赋值<code>nil</code>，但我们在通过<code>self.view</code>获取其值时<strong>一定不为空</strong>。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">null_resettable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIView</span> *view; <span class="hljs-comment">// The getter first invokes [self loadView] if the view hasn&#x27;t been set yet. Subclasses must call super if they override the setter or getter.</span><br><br><span class="hljs-comment">// 大概是这么个创建形式</span><br>- (<span class="hljs-built_in">UIView</span> *)view &#123;<br>  <span class="hljs-keyword">if</span> (_view) <span class="hljs-keyword">return</span> _view;<br>  _view = <span class="hljs-built_in">UIView</span>.new;<br>  <span class="hljs-keyword">return</span> _view;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于<code>null_unspecified</code>倒是很少提及和使用，按照字面意思理解的话，应该是所修饰属性的值和类型都他娘的不确定。而少见的原因大概是果爹仅仅是为了迁移到<code>swift</code>强行加进去的，按着下面的<code>swift</code>代码理解下吧：</li></ul><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-variable">a</span>: <span class="hljs-title class_">String</span><span class="hljs-operator">!</span> <span class="hljs-comment">// 看我，我就是null_unspecified</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>class</code><br>简而言之，就是声明为类属性，是的，也是他娘的为了<code>swift</code>服务的。然后你得自己去实现<code>setter</code>和<code>getter</code>，觉得无聊是吧，我也这么觉得，所以我用的最多的地方就是实现单例类的<code>sharedInstance</code>方法而已。</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// .h</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">class</span>) MyType *sharedInstance;<br><br><span class="hljs-comment">// .m</span><br>+ (<span class="hljs-keyword">instancetype</span>)sharedInstance &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">id</span> instance;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        instance = [[<span class="hljs-keyword">self</span> alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" tabindex="-1">内存管理</h4><p>这个地方可以说是面试的重灾区，而且网上的文章解析一大堆，其实粗浅的说起来也没啥意思的，大家都烂熟于心。而要引申的话，一个关键字可以说一天，也有点过分。综上，还是简单点吧（可不是懒，码农的事怎么能说是偷呢 ---- 窃·格瓦拉·码男）。</p><ul><li><code>weak</code> &amp; <code>assign</code> &amp; <code>unsafe_unretained</code></li></ul><p>给它们仨放一块是因为它们都不会持有修饰的实例，且不会增加引用记数。<code>assign</code>和<code>unsafe_unretained</code>说起来其实没差别，只是从语义上来讲后者用于修饰对象，毕竟<code>retain</code>也算是老牌的<code>strong</code>呢。<code>weak</code>的话，各种长篇大论网上多的是，我这里也不废话了，它相较于其他两种关键字，它会在对象销毁时，将其自动指向nil。</p><p>举，以前用<code>assign</code>修饰<code>delegate</code>实例，然后在<code>dealloc</code>里手动加上<code>_delegate = nil;</code>以杜绝野指针问题，用了<code>weak</code>以后，无残留的特性让我们省力很多。朴实无华的原理就是记录类里面的每个<code>weak</code>的实例，然后在销毁时遍历记录表，一一对比然后<code>referer = nil;</code>就完了。当然啦，落地这个东西涉及的具体细节很多，可以去翻翻源码。</p><ul><li><code>copy</code> &amp; <code>strong</code> &amp; <code>retain</code></li></ul><p>上面一条也提到过，<code>retain</code>算是老牌的<code>strong</code>，老夫很久都没用过<code>retain</code>了。二者特点都是生成新指针指向被引用对象的地址，一处改动，处处改动；不会生成新对象；会增加被引用对象的引用记数，使其生命力更强更持久。</p><p>另外，网上一些说法是在修饰block属性时，两者是有区别的。<code>strong</code>修饰block会有<code>copy</code>行为(所以我们在ARC下写block也没必要用<code>copy</code>)，而<code>retain</code>则没有，仅仅只是个<code>assign</code>的作用。可以随便写个例子，按照<code>Xcode--&gt;Product--&gt;Perform Action--&gt;Assemble &quot;XXX&quot;</code>得到当前类文件的汇编，可以确认这一结论。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// strong修饰</span><br>## -- Begin function -[ViewController setBlock0:]<br><span class="hljs-string">&quot;-[ViewController setBlock0:]&quot;</span>:         ## @<span class="hljs-string">&quot;\01-[ViewController setBlock0:]&quot;</span><br>...<br> callq _objc_setProperty_nonatomic_copy<br>...<br>## -- End function<br><br><span class="hljs-comment">// retain修饰</span><br>## -- Begin function -[ViewController setBlock1:]<br><span class="hljs-string">&quot;-[ViewController setBlock1:]&quot;</span>:         ## @<span class="hljs-string">&quot;\01-[ViewController setBlock1:]&quot;</span><br>...<br>  callq *_objc_release@GOTPCREL(%rip)<br>...<br>## -- End function<br></code></pre></td></tr></table></figure><p>而对于<code>copy</code>的话，也是个面试重灾区，单独拎出来梳理下。个人瞎鸡巴猜它应该是针对OC里的可变及不可变对象派生出来的，那有哪些特点呢？<code>copy</code>是个有针对性的关键字，它修饰的对象<strong>始终是不可变的</strong>；可变对象和不可变对象对应的拷贝方法分别是<code>copy</code>及<code>mutableCopy</code>，其底层对应的也就是<code>copyWithZone:</code>和<code>mutableCopyWithZone</code>，有兴趣可以找找<code>NSCopying</code>和<code>NSMutableCopying</code>协议看看；而<code>copy</code>在修饰不可变对象时平平无奇，表现上与<code>strong</code>无异，新瓶装99，新指针-&gt;老对象，也就是传说中的<strong>浅拷贝</strong>，but在修饰可变对象时会真正的new一个新的不可变对象出来以维持其<strong>始终是不可变的</strong>原则。</p><p>被人说烂的地方就是用<code>copy</code>修饰<code>NSSString</code>比较安全，防止被赋值给它的<code>NSMutableString</code>对象的后续改动牵扯到，可以回顾上面的<code>strong</code>特性。但是极端点的话，随便你用什么关键字修饰，结果我根本不调用<code>xxx.yyy</code>，直接用<code>_yyy</code>去赋值，也还是会存在问题。所以我们在遇见可变对象赋值给不可变对象，一般手动带个[xxx copy]的调用是最靠谱的。</p><p>另外，真不是我偷懒，对<code>NSString *</code>、<code>NSMutableString</code>或者各种可变不可变容器类的深浅拷贝测试代码，网上也是很多很多很多，这里再粘过来也没意思，个人建议为了强化理解和认知，自己写点测试代码是最好不过的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 我们声明的copy属性，最终调用代码</span><br>void objc<span class="hljs-constructor">_setProperty_atomic_copy(<span class="hljs-params">id</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">_cmd</span>, <span class="hljs-params">id</span> <span class="hljs-params">newValue</span>, <span class="hljs-params">ptrdiff_t</span> <span class="hljs-params">offset</span>)</span><br>&#123;<br>    really<span class="hljs-constructor">SetProperty(<span class="hljs-params">self</span>, <span class="hljs-params">_cmd</span>, <span class="hljs-params">newValue</span>, <span class="hljs-params">offset</span>, <span class="hljs-params">true</span>, <span class="hljs-params">true</span>, <span class="hljs-params">false</span>)</span>;<br>&#125;<br><br>void objc<span class="hljs-constructor">_setProperty_nonatomic_copy(<span class="hljs-params">id</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">_cmd</span>, <span class="hljs-params">id</span> <span class="hljs-params">newValue</span>, <span class="hljs-params">ptrdiff_t</span> <span class="hljs-params">offset</span>)</span><br>&#123;<br>    really<span class="hljs-constructor">SetProperty(<span class="hljs-params">self</span>, <span class="hljs-params">_cmd</span>, <span class="hljs-params">newValue</span>, <span class="hljs-params">offset</span>, <span class="hljs-params">false</span>, <span class="hljs-params">true</span>, <span class="hljs-params">false</span>)</span>;<br>&#125;<br><br>static inline void really<span class="hljs-constructor">SetProperty(<span class="hljs-params">id</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">_cmd</span>, <span class="hljs-params">id</span> <span class="hljs-params">newValue</span>, <span class="hljs-params">ptrdiff_t</span> <span class="hljs-params">offset</span>, <span class="hljs-params">bool</span> <span class="hljs-params">atomic</span>, <span class="hljs-params">bool</span> <span class="hljs-params">copy</span>, <span class="hljs-params">bool</span> <span class="hljs-params">mutableCopy</span>)</span><br>&#123;<span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><span class="hljs-keyword">if</span> (copy) &#123;<br>      newValue = <span class="hljs-literal">[<span class="hljs-identifier">newValue</span> <span class="hljs-identifier">copyWithZone</span>:<span class="hljs-identifier">nil</span>]</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mutableCopy) &#123;<br>      newValue = <span class="hljs-literal">[<span class="hljs-identifier">newValue</span> <span class="hljs-identifier">mutableCopyWithZone</span>:<span class="hljs-identifier">nil</span>]</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (*slot<span class="hljs-operator"> == </span>newValue) return;<br>      newValue = objc<span class="hljs-constructor">_retain(<span class="hljs-params">newValue</span>)</span>;<br>  &#125;<span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><h3 id="%E5%9C%A8oc%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E6%88%96%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C" tabindex="-1">在OC中使用实例变量或属性是一种怎样的体验</h3><p>尽管果爹在文档里明确说了，尽可能用属性代替实例变量，其好处多多。但实际上对于用属性好还是用实例变量好，依旧是众口难调，而任何一刀切的做法又都过于极端。看看别人的观点，比如我有个朋友A和B，他们的观点我列在下面：</p><ul><li><p>A，泻药，认为用属性好</p><ul><li>属性写起来似乎很长，但实际上用<strong>CodeSnippets</strong>来写，2个字母就写出来了，而且是具有高可读性，高完整性的声明</li><li>自动创建的<code>setter</code>和<code>getter</code>方法，在需要的时候重写即可，毫无成本，轻松愉快</li><li>更OC，遇到在block中的实例变量，如果用<code>_yyy</code>这种，还会收到循环引用的警告，强迫症的话不得不改成<code>xxx-&gt;_yyy</code>的写法，整的像调用<code>struct</code>一样</li></ul></li><li><p>B，刚下飞机，认为用实例变量好</p><ul><li>属性会从代码层面带来包大小的负担，而且是不可压缩的</li><li>使用<code>xxx.yyy</code>的方式，实际上是在调用方法，某些重写<code>getter</code>的懒加载属性，内部还会执行一次判空，想想就恶心</li><li>通过<code>xxx.yyy = zzz</code>和<code>_yyy = zzz</code>赋值，本质上一个是调用<code>setXxx:</code>方法，一个是直接对变量赋值，但经常看见混用的，强迫症受不了</li><li>补充上一条，某些<code>lazy code</code>还必须用<code>_yyy</code>这种形式，否则可能会过早的创建实例导致不符预期的行为，所以每次使用的时候还要过脑子，增加额外的脑细胞劳损</li></ul></li></ul><p>个人认为，既然大家都喜欢吹牛逼，说是要对写的每一行代码负责，那么在使用属性或者实例变量的时候，如果有统一的规范约束，那就是答案，如果没有就想想为什么这里用属性那里用变量，无论是追求官网风格、大神洁癖、装B、没理由、我流、无脑流等等，都是属于你个人行为意识的体现，没有绝对的好坏之分，只是当别人问你时，必须要自信的给出你的答案，让人拍腿直呼霸气外露，这事就算成了。</p><h2 id="%E5%90%8E%E8%AE%B0" tabindex="-1">后记</h2><p>能坚持看到这里的都是真爱，先说声谢谢，分享的东西都很粗浅，但是知道概念是一回事，很好的表达出来又是一回事，所以才有了这个花果山。同时我也还是希望给大家带来满满的正能量，所以再补充些骚话：回头看看我自己的开发历程，都只是摸爬滚打，靠着一腔兴趣撑到现在，而终于没有一个领域精通或者擅长，都是浅浅的浮于表面；一方面是自己没有做足够的回顾总结，另一方面没有意识去培养系统化思考，高效的学习方法等，所以一直处理半桶水的样子；建这个花果山的初衷，也是希望像那些大佬一样，坚持阅读和学习，总结记录，有条理有思考，能够沉淀足够多的能量，突破自我。</p><h2 id="%E5%8F%82%E8%80%83%E8%BF%9E%E6%8E%A5" tabindex="-1">参考连接</h2><ul><li><a href="https://developer.apple.com/library/archive/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html">Encapsulating Data</a></li><li><a href="https://swiftunboxed.com/interop/objc-nullability-annotations/">Nullability Annotations in Objective-C</a></li><li><a href="http://www.saitjr.com/ios/apple-api-nullability.html">『Apple API』Nullability</a></li><li><a href="http://lists.llvm.org/pipermail/cfe-dev/2015-June/043698.html">[cfe-dev] RFC: Nullability qualifiers</a></li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开篇一包烟，剩下全靠编</title>
    <link href="/2020/09/01/initial/"/>
    <url>/2020/09/01/initial/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/09/01/initial/qz.jpg" alt></p><p>开了这个写骚话的地方，大概花费不到20分钟，却硬是拖延了好几年。真的发布了一血文章后，在浏览器输入地址，打开，看见，这确确实实让人有种说不出的快感。</p><span id="more"></span><p>我以前是喜欢写东西的，而且是强迫症晚期的那种。对于看过的书我会写满骚话，作者说一句“啊，世界多么美好”，我会冷静的在旁边加一句“美好个J∞”，一来满足杠精的本能，二来是因为有把空白处全写满文字的冲动，所以我也是对Markdown铺张浪费的排版感到揪心。我也曾写过日记，受限于另一种高优的强迫症规则，日记篇幅必须大于等于一页纸，所以我启用了铺张浪费的能力，一行字占两行纸，字间距能塞下一只小强，偶尔感悟多一点，也得确能写个几页。然而美好而充实的记录行为持续没多久，一道晴天霹雳助我渡劫，让原本就懒惰的性格雪上加霜，飞升成懒仙。“正经人谁写日记啊”，MD，当我听到这句台词之后，为了证明自己是个正经人，真的就没再写过日记，甚至连小而美和突如其来的骚话都不记录了。我终于成了个正经人，眼里的色彩慢慢变得纯粹单调，聚焦在工作和休息，以持重稳健和正能量的态度，全力投入在搬砖之路上。</p><p>而今由于某些变化，我内心骚浪贱的澎湃越来越甚，就如同青春热血的少年们在发情的时候，拼命压抑到最后终归是意志失去对双手的掌控，我不再压抑自己，我开始胡思乱想，开始放飞思绪，开始思考生存以外的东西。也正因如此，让我产生一丝明悟：你追求的东西，或许不在你脚下，或许你走着走着却又在了；人不是慢慢学会撸管的，人是在一瞬间学会的；得之我幸，不得我命，如此而已。</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
    <categories>
      
      <category>东城往事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正能量</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
